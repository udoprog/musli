//! [<img alt="github" src="https://img.shields.io/badge/github-udoprog/musli-8da0cb?style=for-the-badge&logo=github" height="20">](https://github.com/udoprog/musli)
//! [<img alt="crates.io" src="https://img.shields.io/crates/v/musli-tests.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20">](https://crates.io/crates/musli-tests)
//! [<img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-musli--tests-66c2a5?style=for-the-badge&logoColor=white&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDUxMiA1MTIiPjxwYXRoIGZpbGw9IiNmNWY1ZjUiIGQ9Ik00ODguNiAyNTAuMkwzOTIgMjE0VjEwNS41YzAtMTUtOS4zLTI4LjQtMjMuNC0zMy43bC0xMDAtMzcuNWMtOC4xLTMuMS0xNy4xLTMuMS0yNS4zIDBsLTEwMCAzNy41Yy0xNC4xIDUuMy0yMy40IDE4LjctMjMuNCAzMy43VjIxNGwtOTYuNiAzNi4yQzkuMyAyNTUuNSAwIDI2OC45IDAgMjgzLjlWMzk0YzAgMTMuNiA3LjcgMjYuMSAxOS45IDMyLjJsMTAwIDUwYzEwLjEgNS4xIDIyLjEgNS4xIDMyLjIgMGwxMDMuOS01MiAxMDMuOSA1MmMxMC4xIDUuMSAyMi4xIDUuMSAzMi4yIDBsMTAwLTUwYzEyLjItNi4xIDE5LjktMTguNiAxOS45LTMyLjJWMjgzLjljMC0xNS05LjMtMjguNC0yMy40LTMzLjd6TTM1OCAyMTQuOGwtODUgMzEuOXYtNjguMmw4NS0zN3Y3My4zek0xNTQgMTA0LjFsMTAyLTM4LjIgMTAyIDM4LjJ2LjZsLTEwMiA0MS40LTEwMi00MS40di0uNnptODQgMjkxLjFsLTg1IDQyLjV2LTc5LjFsODUtMzguOHY3NS40em0wLTExMmwtMTAyIDQxLjQtMTAyLTQxLjR2LS42bDEwMi0zOC4yIDEwMiAzOC4ydi42em0yNDAgMTEybC04NSA0Mi41di03OS4xbDg1LTM4Ljh2NzUuNHptMC0xMTJsLTEwMiA0MS40LTEwMi00MS40di0uNmwxMDItMzguMiAxMDIgMzguMnYuNnoiPjwvcGF0aD48L3N2Zz4K" height="20">](https://docs.rs/musli-tests)
//!
//! Helper utilities for ensuring that musli is safe to use and behaves as expected.
//!
//! This does include a fairly sophisticated benchmarking suite.
//!
//! <br>
//!
//! ## Benchmarking
//!
//! Now this includes the `extra` category, which requires `model_minimal`. This
//! is not exactly a fair comparison, because it compares serialization formats
//! which were designed to model data that others are not capable off.
//!
//! The exact tradeoff can be seen by comparing the feature `model_full` with
//! `model_minimal`.
//!
//! ```sh
//! cargo bench --no-default-features --features musli,full,extra,model_minimal,simdutf8
//! ```
//!
//! To run benchmarks for serialization suites which *do* support all features, do:
//!
//! ```sh
//! cargo bench --features full
//! ```
//!
//! <br>
//!
//! ## Fuzz testing
//!
//! This comes with the `fuzz` binary which can do the following things.
//!
//! Run serialization for a long time against a lot of random data. Both with
//! and without miri. When run with miri, the size of the datasets is
//! drastically reduced.
//!
//! ```sh
//! cargo run --bin fuzz
//! cargo +nightly miri run --bin fuzz
//! ```
//!
//! Run deserialization against randomly generated bytes. Both with and without
//! miri. When run with miri, the size of the datasets is drastically reduced.
//!
//! ```sh
//! cargo run --bin fuzz -- --random
//! cargo +nightly miri run --bin fuzz -- --random
//! ```
//!
//! > **Note** you can add the running of optional crates by enabling its
//! > corresponding feature, such as `--features bincode`.
//!
//! <br>
//!
//! ## Potential security issues discovered by this crate
//!
//! * `dlhn`: Allocating and initializing large arrays based on untrusted input
//!   (DoS): [dlhn#11](https://github.com/otake84/dlhn/issues/11).
//!
//! <br>
//!
//! ## Size comparison
//!
//! To perform a one-off size comparison:
//!
//! ```sh
//! cargo run --bin fuzz -- --size
//! ```
//!
//! This will *for now* just take the first generated field of a given type,
//! serialize it, and print out its size. In the future it will perform an
//! average over the entire set with more statistics.

#![no_std]

extern crate alloc;

#[cfg(feature = "std")]
extern crate std;

const RNG_SEED: u64 = 2718281828459045235;

#[macro_export]
macro_rules! miri {
    ($($(#[$($meta:meta)*])* const $ident:ident: $value_ty:ty = $range:expr, $miri:expr;)*) => {
        $(
            $(#[$($meta)*])*
            #[cfg(miri)]
            const $ident: $value_ty = $miri;
            $(#[$($meta)*])*
            #[cfg(not(miri))]
            const $ident: $value_ty = $range;
        )*
    }
}

// Defines denies feature combinations.
//
// * Negative features are not supported in cargo, and feature blocking
//   everything is too complex. model_map for example also depends on std.
// * Benchmarks for these must be explicitly run, because they only include a
//   subset of available data, we wouldn't be doing an apples-to-apples
//   comparison if we allowed only a model subset to be compared against a
//   serialization which supports a superset. If you do want to make this
//   comparison, you can enable `model_minimal`.
macro_rules! deny {
    ($base:literal $(, $feature:literal)*) => {
        $(
            #[cfg(all(feature = $base, feature = $feature))]
            compile_error!(concat!($base, ": does not support feature: ", $feature));
        )*
    }
}

deny!("rkyv", "model_tuple", "model_map_string_key", "model_usize");
deny!("dlhn", "model_map", "model_128");
deny!("bitcode", "model_128");

mod mode;
pub mod models;
pub mod utils;

#[cfg(feature = "musli-wire")]
pub mod wire {
    pub use musli_wire::*;
}

#[cfg(feature = "musli-storage")]
pub mod storage {
    pub use musli_storage::*;
}

#[cfg(feature = "musli-descriptive")]
pub mod s {
    pub use musli_descriptive::*;
}

/// Roundtrip the given expression through all supported formats.
#[cfg(all(
    feature = "musli-wire",
    feature = "musli-storage",
    feature = "musli-descriptive"
))]
#[macro_export]
macro_rules! rt {
    ($($tt:tt)*) => {{
        let a = ::musli_wire::rt!($($tt)*);
        let b = ::musli_storage::rt!($($tt)*);
        let c = ::musli_descriptive::rt!($($tt)*);
        assert_eq!(a, b);
        assert_eq!(a, c);
        a
    }};
}

#[macro_export]
macro_rules! musli_zerocopy_call {
    ($call:path) => {
    };

    ($call:path, prim, $ty:ty, $size_hint:expr $(, $tt:tt)*) => {
        $call!(musli_value, musli_value_buf, prim, $ty, $size_hint);
        $crate::musli_zerocopy_call!($call $(, $tt)*);
    };

    // Ignore others.
    ($call:path, $name:ident, $ty:ty, $size_hint:expr $(, $tt:tt)*) => {
        $crate::musli_zerocopy_call!($call $(, $tt)*);
    };
}

/// Call the given macro with the existing feature matrix.
#[macro_export]
macro_rules! feature_matrix {
    ($call:path $(, $($tt:tt)*)?) => {
        #[cfg(feature = "serde_json")]
        $call!(serde_json, serde_json_buf $(, $($tt)*)*);
        #[cfg(feature = "bincode")]
        $call!(serde_bincode, serde_bincode_buf $(, $($tt)*)*);
        #[cfg(feature = "rmp-serde")]
        $call!(serde_rmp, serde_rmp_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-json")]
        $call!(musli_json, musli_json_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-wire")]
        $call!(musli_wire, musli_wire_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-descriptive")]
        $call!(musli_descriptive, musli_descriptive_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-storage")]
        $call!(musli_storage, musli_storage_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-storage")]
        $call!(musli_storage_packed, musli_storage_packed_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-value")]
        $call!(musli_value, musli_value_buf $(, $($tt)*)*);
        #[cfg(feature = "musli-zerocopy")]
        $call!(musli_zerocopy, musli_zerocopy_buf $(, $($tt)*)*);
        #[cfg(all(feature = "dlhn", not(any(model_128, model_all))))]
        $call!(serde_dlhn, serde_dlhn_buf $(, $($tt)*)*);
        #[cfg(feature = "serde_cbor")]
        $call!(serde_cbor, serde_cbor_buf $(, $($tt)*)*);
        #[cfg(feature = "bitcode")]
        $call!(serde_bitcode, serde_bitcode_buf $(, $($tt)*)*);
        #[cfg(feature = "bitcode")]
        $call!(derive_bitcode, derive_bitcode_buf $(, $($tt)*)*);
        #[cfg(feature = "rkyv")]
        $call!(rkyv, rkyv_buf $(, $($tt)*)*);
        #[cfg(feature = "postcard")]
        $call!(postcard, postcard_buf $(, $($tt)*)*);
    };
}

#[macro_export]
macro_rules! types {
    ($call:path $(, $($tt:tt)*)?) => {
        #[cfg(not(feature = "musli-zerocopy"))]
        $call! {
            $($($tt)*,)?
            prim, Primitives, PRIMITIVES, 1000,
            lg, LargeStruct, LARGE_STRUCTS, 10000,
            allocated, Allocated, ALLOCATED, 5000,
            medium_enum, MediumEnum, MEDIUM_ENUMS, 1000
        };

        #[cfg(feature = "musli-zerocopy")]
        $call! {
            $($($tt)*,)?
            prim, Primitives, PRIMITIVES, 1000
        };
    }
}

/// Build common RNG.
pub fn rng() -> rand::prelude::StdRng {
    use rand::prelude::*;
    rand::prelude::StdRng::seed_from_u64(RNG_SEED)
}
